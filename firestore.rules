/**
 * @fileoverview Firestore Security Rules for the FoodReels application.
 *
 * Core Philosophy:
 * This ruleset enforces a strict user-ownership model for user-specific data
 * (profiles, carts, orders) while allowing public read access to videos, products,
 * and stories.  It uses a global "admin" role based on the existence of a
 * document in the `/roles_admin/{userId}` collection. All write operations
 * require authentication.
 *
 * Data Structure:
 * - /users/{userId}: User profile data. Only the user themselves can modify it.
 * - /videos/{videoId}: Video metadata. Publicly readable, but only the creator can modify.
 * - /likes/{likeId}: User likes for videos.
 * - /products/{productId}: Product information related to videos. Publicly readable.
 * - /users/{userId}/cart/{cartItemId}: User's shopping cart. Only the user can modify.
 * - /users/{userId}/orders/{orderId}: User's order history. Only the user can access.
 * - /users/{userId}/orders/{orderId}/orderItems/{orderItemId}: Items within an order.
 * - /stories/{storyId}: Short-lived stories. Publicly readable, creator-owned writes.
 * - /roles_admin/{userId}: Grants admin privileges to a user.
 *
 * Key Security Decisions:
 * - Users cannot list other users.
 * - Public read access is granted to videos, products and stories.
 * - Default security posture for ambiguous relationships is strict owner-only access.
 * - No data validation is performed in these rules beyond authorization checks.
 *
 * Denormalization for Authorization:
 * - Videos store the creatorId directly on the video document for easy ownership checks.
 * - Likes store the userId and videoId for querying likes.
 *
 * Structural Segregation:
 * - User-specific data (cart, orders) is stored under the /users/{userId} path to enforce ownership.
 */
rules_version = '2';
service cloud.firestore {
  match /databases/{database}/documents {

    /**
     * @description Checks if the user is signed in.
     * @path N/A
     * @allow N/A
     * @deny N/A
     * @principle Requires authentication for certain operations.
     */
    function isSignedIn() {
      return request.auth != null;
    }

    /**
     * @description Checks if the authenticated user's ID matches the provided user ID.
     * @path N/A
     * @allow N/A
     * @deny N/A
     * @principle Enforces user-based ownership.
     */
    function isOwner(userId) {
      return isSignedIn() && request.auth.uid == userId;
    }

    /**
     * @description Checks if the authenticated user is an existing owner of a resource.
     * @path N/A
     * @allow N/A
     * @deny N/A
     * @principle Validates resource existence before modification.
     */
    function isExistingOwner(userId) {
      return isOwner(userId) && resource != null;
    }

    /**
     * @description Checks if the authenticated user has admin privileges.
     * @path N/A
     * @allow N/A
     * @deny N/A
     * @principle Implements a role-based access control.
     */
    function isAdmin() {
        return exists(/databases/$(database)/documents/roles_admin/$(request.auth.uid));
    }

    /**
     * @description Rule for user profiles.
     * @path /users/{userId}
     * @allow (create) User with ID 'user123' creates their own profile.
     *    - request.auth.uid: 'user123'
     *    - request.resource.data.id: 'user123'
     * @allow (update) User with ID 'user123' updates their profile.
     *    - request.auth.uid: 'user123'
     * @deny (create) User with ID 'user456' attempts to create a profile for 'user123'.
     *    - request.auth.uid: 'user456'
     *    - request.resource.data.id: 'user123'
     * @deny (update) User with ID 'user456' attempts to update the profile of 'user123'.
     *    - request.auth.uid: 'user456'
     * @principle Enforces document ownership for writes, restricts listing to admins.
     */
    match /users/{userId} {
      allow get: if isOwner(userId) || isAdmin();
      allow list: if false;
      allow create: if isOwner(userId) && request.resource.data.id == userId;
      allow update: if isExistingOwner(userId) && request.resource.data.id == resource.data.id;
      allow delete: if isExistingOwner(userId);
    }

    /**
     * @description Rule for videos.
     * @path /videos/{videoId}
     * @allow (get, list) Any user can read video metadata.
     * @allow (create) User creates a video with their ID as the creatorId.
     *    - request.auth.uid: 'user123'
     *    - request.resource.data.creatorId: 'user123'
     * @allow (update) User updates their video with their ID matching the creatorId.
     *    - request.auth.uid: 'user123'
     *    - resource.data.creatorId: 'user123'
     * @deny (create) User attempts to create a video with someone else's ID as the creatorId.
     *    - request.auth.uid: 'user123'
     *    - request.resource.data.creatorId: 'user456'
     * @deny (update) User attempts to update someone else's video.
     *    - request.auth.uid: 'user456'
     *    - resource.data.creatorId: 'user123'
     * @principle Allows public read access but enforces creator-based ownership for writes.
     */
    match /videos/{videoId} {
      allow get: if true;
      allow list: if true;
      allow create: if isSignedIn() && request.resource.data.creatorId == request.auth.uid;
      allow update: if isSignedIn() && resource != null && resource.data.creatorId == request.auth.uid;
      allow delete: if isSignedIn() && resource != null && resource.data.creatorId == request.auth.uid;
    }

    /**
     * @description Rule for likes.
     * @path /likes/{likeId}
     * @allow (create) User creates a like with their ID as the userId.
     *    - request.auth.uid: 'user123'
     *    - request.resource.data.userId: 'user123'
     * @allow (get) Any user can retrieve like information.
     * @deny (create) User attempts to create a like with someone else's ID as the userId.
     *    - request.auth.uid: 'user123'
     *    - request.resource.data.userId: 'user456'
     * @principle Allows public read access but enforces user-based ownership for writes.
     */
    match /likes/{likeId} {
      allow get: if true;
      allow list: if true;
      allow create: if isSignedIn() && request.resource.data.userId == request.auth.uid;
      allow update: if false;
      allow delete: if isSignedIn() && resource != null && request.resource.data.userId == request.auth.uid; //Added a check to make sure the delete is done by the user
    }

    /**
     * @description Rule for products.
     * @path /products/{productId}
     * @allow (get, list) Any user can read product information.
     * @allow create: if false; // TODO: Add owner validation once the schema is updated with an ownership field.
     * @allow update: if false; // TODO: Add owner validation once the schema is updated with an ownership field.
     * @allow delete: if false; // TODO: Add owner validation once the schema is updated with an ownership field.
     * @principle Allows public read access, but restricts writes.
     */
    match /products/{productId} {
      allow get: if true;
      allow list: if true;
      allow create: if false; // TODO: Add owner validation once the schema is updated with an ownership field.
      allow update: if false; // TODO: Add owner validation once the schema is updated with an ownership field.
      allow delete: if false; // TODO: Add owner validation once the schema is updated with an ownership field.
    }

    /**
     * @description Rule for cart items.
     * @path /users/{userId}/cart/{cartItemId}
     * @allow (create) User with ID 'user123' creates a cart item in their cart.
     *    - request.auth.uid: 'user123'
     * @allow (update) User with ID 'user123' updates a cart item in their cart.
     *    - request.auth.uid: 'user123'
     * @deny (create) User with ID 'user456' attempts to create a cart item in 'user123's cart.
     *    - request.auth.uid: 'user456'
     * @deny (update) User with ID 'user456' attempts to update a cart item in 'user123's cart.
     *    - request.auth.uid: 'user456'
     * @principle Enforces document ownership for writes.
     */
    match /users/{userId}/cart/{cartItemId} {
      allow get: if isOwner(userId);
      allow list: if isOwner(userId);
      allow create: if isOwner(userId);
      allow update: if isExistingOwner(userId);
      allow delete: if isExistingOwner(userId);
    }

    /**
     * @description Rule for orders.
     * @path /users/{userId}/orders/{orderId}
     * @allow (create) User with ID 'user123' creates an order in their order history.
     *    - request.auth.uid: 'user123'
     * @allow (update) User with ID 'user123' updates an order in their order history.
     *    - request.auth.uid: 'user123'
     * @deny (create) User with ID 'user456' attempts to create an order in 'user123's order history.
     *    - request.auth.uid: 'user456'
     * @deny (update) User with ID 'user456' attempts to update an order in 'user123's order history.
     *    - request.auth.uid: 'user456'
     * @principle Enforces document ownership for writes.
     */
    match /users/{userId}/orders/{orderId} {
      allow get: if isOwner(userId);
      allow list: if isOwner(userId);
      allow create: if isOwner(userId);
      allow update: if isExistingOwner(userId);
      allow delete: if isExistingOwner(userId);
    }

    /**
     * @description Rule for order items.
     * @path /users/{userId}/orders/{orderId}/orderItems/{orderItemId}
     * @allow (create) User with ID 'user123' creates an order item in their order.
     *    - request.auth.uid: 'user123'
     * @allow (update) User with ID 'user123' updates an order item in their order.
     *    - request.auth.uid: 'user123'
     * @deny (create) User with ID 'user456' attempts to create an order item in 'user123's order.
     *    - request.auth.uid: 'user456'
     * @deny (update) User with ID 'user456' attempts to update an order item in 'user123's order.
     *    - request.auth.uid: 'user456'
     * @principle Enforces document ownership for writes.
     */
    match /users/{userId}/orders/{orderId}/orderItems/{orderItemId} {
      allow get: if isOwner(userId);
      allow list: if isOwner(userId);
      allow create: if isOwner(userId);
      allow update: if isExistingOwner(userId);
      allow delete: if isExistingOwner(userId);
    }

    /**
     * @description Rule for stories.
     * @path /stories/{storyId}
     * @allow (get, list) Any user can read story metadata.
     * @allow (create) User creates a story with their ID as the creatorId.
     *    - request.auth.uid: 'user123'
     *    - request.resource.data.creatorId: 'user123'
     * @allow (update) User updates their story with their ID matching the creatorId.
     *    - request.auth.uid: 'user123'
     *    - resource.data.creatorId: 'user123'
     * @deny (create) User attempts to create a story with someone else's ID as the creatorId.
     *    - request.auth.uid: 'user123'
     *    - request.resource.data.creatorId: 'user456'
     * @deny (update) User attempts to update someone else's story.
     *    - request.auth.uid: 'user456'
     *    - resource.data.creatorId: 'user123'
     * @principle Allows public read access but enforces creator-based ownership for writes.
     */
    match /stories/{storyId} {
      allow get: if true;
      allow list: if true;
      allow create: if isSignedIn() && request.resource.data.creatorId == request.auth.uid;
      allow update: if isSignedIn() && resource != null && resource.data.creatorId == request.auth.uid;
      allow delete: if isSignedIn() && resource != null && resource.data.creatorId == request.auth.uid;
    }

    /**
     * @description Rule for admin roles.
     * @path /roles_admin/{userId}
     * @allow (create) Only an existing admin can grant admin privileges to another user.
     *    - request.auth.uid: 'admin123' (who already has a document in /roles_admin/{admin123})
     *    - request.resource.id: 'user456' (the user being granted admin)
     * @allow (get, list) Only admins can read the roles_admin collection.
     * @deny (create) A non-admin user attempts to grant admin privileges.
     *    - request.auth.uid: 'user123' (who does NOT have a document in /roles_admin/{user123})
     *    - request.resource.id: 'user456'
     * @deny (delete) A non-admin attempts to revoke admin privileges.
     *    - request.auth.uid: 'user123'
     * @principle Existence of a document grants admin privileges. Restricted write access to existing admins.
     */
    match /roles_admin/{userId} {
      allow get: if isAdmin();
      allow list: if isAdmin();
      allow create: if isAdmin();
      allow update: if false;
      allow delete: if isAdmin() && resource != null;
    }
  }
}